/**
 * Comparison Engine
 *
 * Central orchestrator for visual comparison across all tiers:
 * 1. Design parsing (Figma/tokens)
 * 2. Build screenshot + DOM extraction
 * 3. DOM property comparison
 * 4. Pixel-level comparison
 * 5. Feedback generation
 */

import { ScreenshotEngine } from './screenshot-engine.js';
import { DesignParser } from './design-parser.js';
import { PixelComparator } from './pixel-comparator.js';
import { DOMComparator } from './dom-comparator.js';
import { FeedbackGenerator } from './feedback-generator.js';
import { SSIMComparator } from './ssim-comparator.js';
import { VLMComparator } from './vlm-comparator.js';
import { PencilParser } from './pencil-parser.js';
import { DesignRenderer } from './design-renderer.js';
import type {
  ComparisonResult,
  OverallScore,
  Viewport,
  DesignState,
  ScreenshotResult,
  DOMDiffResult,
  DOMElementStyle,
  PixelDiffResult,
  DiffRegion,
  MLMetrics,
  VLMEvaluation,
} from './types.js';

export interface CompareOptions {
  designSource: {
    figmaFileKey?: string;
    figmaNodeId?: string;
    tokenFile?: string;
    referenceImage?: string;
    designState?: DesignState;
    pencilFile?: string;
    pencilFrame?: string;
    pencilTheme?: string;
  };
  buildUrl: string;
  viewport?: Viewport;
  selector?: string;
  threshold?: number;
  enableSSIM?: boolean;
  enableVLM?: boolean;
}

export class ComparisonEngine {
  private screenshotEngine: ScreenshotEngine;
  private designParser: DesignParser;
  private pixelComparator: PixelComparator;
  private domComparator: DOMComparator;
  private feedbackGenerator: FeedbackGenerator;
  private ssimComparator: SSIMComparator;
  private vlmComparator: VLMComparator;

  constructor() {
    this.screenshotEngine = new ScreenshotEngine();
    this.designParser = new DesignParser();
    this.pixelComparator = new PixelComparator();
    this.domComparator = new DOMComparator();
    this.feedbackGenerator = new FeedbackGenerator();
    this.ssimComparator = new SSIMComparator();
    this.vlmComparator = new VLMComparator();
  }

  /**
   * Initialize the screenshot engine (launches browser).
   */
  async init(): Promise<void> {
    await this.screenshotEngine.init();
  }

  /**
   * Compare build against design and generate feedback.
   *
   * Orchestrates:
   * 1. Load design state (from Figma or cached)
   * 2. Capture build screenshot + DOM styles
   * 3. Run DOM property comparison (~50ms, fastest)
   * 4. Run pixel diff (~100ms)
   * 5. Aggregate results
   * 6. Generate feedback
   * 7. Compute overall score and grade
   */
  async compare(options: CompareOptions): Promise<ComparisonResult> {
    const startTime = Date.now();

    // 1. Load design state + capture build screenshot (parallel when viewport known) (t-001)
    let designState: DesignState;
    let screenshotResult: ScreenshotResult;

    if (options.viewport) {
      // Viewport explicitly provided — can parallelize
      [designState, screenshotResult] = await Promise.all([
        this.loadDesignState(options.designSource),
        this.screenshotEngine.capture({
          url: options.buildUrl,
          viewport: options.viewport,
          selector: options.selector,
          disableAnimations: true,
        }),
      ]);
    } else {
      // Need design state first for viewport
      designState = await this.loadDesignState(options.designSource);
      screenshotResult = await this.screenshotEngine.capture({
        url: options.buildUrl,
        viewport: designState.viewport || options.viewport,
        selector: options.selector,
        disableAnimations: true,
      });
    }

    // 3. Run DOM property comparison
    const domDiff = this.domComparator.compare(
      screenshotResult.domStyles || [],
      designState.nodes
    );

    // 4. Run pixel diff (need design reference image)
    let pixelDiff: PixelDiffResult;
    let regions: DiffRegion[] = [];

    let referenceBuffer: Buffer | null = null;
    let referenceIsAutoGenerated = false;

    if (options.designSource.referenceImage) {
      referenceBuffer = await this.loadReferenceImage(options.designSource.referenceImage);
    } else if (designState.nodes.length > 0) {
      referenceIsAutoGenerated = true;
      // Auto-generate reference screenshot from design state
      try {
        // Use the same viewport as the build screenshot for consistent dimensions
        const refViewport = options.viewport || designState.viewport;
        const renderer = new DesignRenderer();
        const html = renderer.render(
          designState.nodes,
          refViewport.width,
          refViewport.height
        );
        const fs = await import('fs/promises');
        const path = await import('path');
        const os = await import('os');
        const tmpPath = path.join(os.tmpdir(), `saccadic-design-${Date.now()}.html`);
        await fs.writeFile(tmpPath, html, 'utf-8');
        const refScreenshot = await this.screenshotEngine.capture({
          url: `file://${tmpPath}`,
          viewport: refViewport,
          disableAnimations: true,
        });
        referenceBuffer = refScreenshot.image;
        await fs.unlink(tmpPath).catch(() => {});
      } catch {
        // Fall back to no pixel comparison if rendering fails
        referenceBuffer = null;
      }
    }

    if (referenceBuffer) {
      // Run full pixel comparison
      const pixelResult = this.pixelComparator.compare(
        referenceBuffer,
        screenshotResult.image,
        { threshold: options.threshold || 0.1 }
      );
      pixelDiff = pixelResult;

      // Selective region detection (t-007): only find regions in DOM mismatch areas when possible
      if (pixelResult.diffImage && pixelResult.diffPixels > 0) {
        const { PNG } = await import('pngjs');
        const png = PNG.sync.read(pixelResult.diffImage);
        const allRegions = this.pixelComparator.findDiffRegions(pixelResult.diffImage, png.width, png.height);

        // If DOM comparison found mismatch elements, prioritize regions overlapping those elements
        if (domDiff.mismatches.length > 0 && screenshotResult.domStyles) {
          const mismatchElements = new Set(domDiff.mismatches.map(m => m.element));
          const mismatchBounds = screenshotResult.domStyles
            .filter(s => mismatchElements.has(s.selector))
            .map(s => s.bounds);

          // Keep regions that overlap with mismatch elements, plus any large standalone regions
          const viewportArea = (designState.viewport?.width || 1280) * (designState.viewport?.height || 800);
          regions = allRegions.filter(region => {
            const regionArea = region.bounds.width * region.bounds.height;
            // Always keep large regions (>1% of viewport)
            if (regionArea / viewportArea > 0.01) return true;
            // Keep regions overlapping DOM mismatch elements
            return mismatchBounds.some(b => this.boundsOverlap(b, region.bounds));
          });
        } else {
          regions = allRegions;
        }
      }
    } else {
      pixelDiff = {
        totalPixels: 0,
        diffPixels: 0,
        diffPercentage: 0,
        pixelComparisonRan: false,
      };
    }

    // 5. SSIM (optional, requires reference image)
    let mlMetrics: MLMetrics | undefined;
    if (options.enableSSIM && referenceBuffer) {
      mlMetrics = this.ssimComparator.compare(referenceBuffer, screenshotResult.image);
    }

    // 6. VLM evaluation (optional, requires API key and real reference image)
    let vlmEvaluation: VLMEvaluation | undefined;
    if (options.enableVLM && referenceBuffer && !referenceIsAutoGenerated && this.vlmComparator.isAvailable()) {
      vlmEvaluation = await this.vlmComparator.compare({
        designImage: referenceBuffer,
        buildImage: screenshotResult.image,
      });
    }

    // 7. Generate feedback
    const feedback = this.feedbackGenerator.generate(
      domDiff,
      pixelDiff,
      regions,
      screenshotResult.domStyles
    );

    // 8. Compute overall score (with viewport-weighted severity)
    const overall = this.computeOverallScore(
      domDiff, pixelDiff, regions,
      designState.viewport || options.viewport,
      screenshotResult.domStyles
    );

    return {
      overall,
      domDiff,
      pixelDiff,
      regions,
      feedback,
      timestamp: startTime,
      mlMetrics,
      vlmEvaluation,
    };
  }

  /**
   * Run comparison across multiple viewports with cross-viewport consistency checks (t-012).
   */
  async compareMultiViewport(
    options: CompareOptions,
    viewports: Viewport[],
    concurrency = 3
  ): Promise<Map<string, ComparisonResult>> {
    const results: Array<readonly [string, ComparisonResult]> = [];

    // Process viewports with concurrency limit to avoid browser resource contention
    for (let i = 0; i < viewports.length; i += concurrency) {
      const batch = viewports.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(async (viewport) => {
          const result = await this.compare({ ...options, viewport });
          const key = `${viewport.width}x${viewport.height}`;
          return [key, result] as const;
        })
      );
      results.push(...batchResults);
    }

    const resultsMap = new Map(results);

    // Cross-viewport consistency checks (t-012)
    if (results.length >= 2) {
      const viewportKeys = results.map(([key]) => key);
      const allMissing = new Map<string, string[]>(); // element → viewports where missing

      for (const [key, result] of results) {
        for (const missingEl of result.domDiff.missing) {
          if (!allMissing.has(missingEl)) allMissing.set(missingEl, []);
          allMissing.get(missingEl)!.push(key);
        }
      }

      // Elements that appear in some viewports but disappear in others
      for (const [element, missingIn] of allMissing) {
        if (missingIn.length < viewportKeys.length) {
          // Element exists in some viewports but not all — likely a responsive breakpoint issue
          const presentIn = viewportKeys.filter(k => !missingIn.includes(k));
          for (const key of missingIn) {
            const result = resultsMap.get(key);
            if (result) {
              result.feedback.push({
                severity: 'warn',
                category: 'layout',
                message: `Element "${element}" disappears at ${key} but is present at ${presentIn.join(', ')}. Check responsive breakpoints.`,
                element,
              });
            }
          }
        }
      }
    }

    return resultsMap;
  }

  /**
   * Compute overall match score and grade.
   *
   * Grade scale:
   * - A: >95% match
   * - B: >85% match
   * - C: >70% match
   * - D: >50% match
   * - F: <50% match
   */
  private computeOverallScore(
    domDiff: DOMDiffResult,
    pixelDiff: PixelDiffResult,
    regions: DiffRegion[],
    viewport?: Viewport,
    domStyles?: DOMElementStyle[]
  ): OverallScore {
    // Weight DOM comparison heavily (it's more precise)
    // domTotal counts unique *elements*: matched + missing (unmatched design nodes)
    // mismatches are property-level issues on matched elements, not separate elements
    const domTotal = domDiff.matches + domDiff.missing.length;
    const domMatchRate = domTotal > 0 ? domDiff.matches / domTotal : 1;

    // Pixel diff is secondary (can have false positives)
    // diffPercentage is 0-100, convert to 0-1 fraction
    const pixelMatchRate = 1 - (pixelDiff.diffPercentage / 100);

    // Viewport-weighted severity (t-008): weight penalties by element area
    const viewportArea = (viewport?.width || 1280) * (viewport?.height || 800);
    const elementBoundsMap = new Map<string, { width: number; height: number }>();
    if (domStyles) {
      for (const s of domStyles) {
        elementBoundsMap.set(s.selector, { width: s.bounds.width, height: s.bounds.height });
      }
    }

    // Count unique elements with fail/warn mismatches, weighted by visual salience
    let weightedFailPenalty = 0;
    let weightedWarnPenalty = 0;

    const elementsWithFails = new Set(
      domDiff.mismatches.filter((m) => m.severity === 'fail').map((m) => m.element)
    );
    const elementsWithWarns = new Set(
      domDiff.mismatches.filter((m) => m.severity === 'warn').map((m) => m.element)
    );

    // Compute area-weighted penalties for DOM mismatches
    for (const el of elementsWithFails) {
      const bounds = elementBoundsMap.get(el);
      const salience = bounds ? Math.max(0.1, (bounds.width * bounds.height) / viewportArea) : 0.1;
      // Salience multiplier: clamp between 0.5x (tiny elements) and 2x (large elements)
      const multiplier = Math.min(2, Math.max(0.5, salience * 10));
      weightedFailPenalty += multiplier;
    }

    // Missing elements get default weight
    weightedFailPenalty += domDiff.missing.length;
    weightedFailPenalty += regions.filter((r) => r.severity === 'fail').length;

    for (const el of elementsWithWarns) {
      const bounds = elementBoundsMap.get(el);
      const salience = bounds ? Math.max(0.1, (bounds.width * bounds.height) / viewportArea) : 0.1;
      const multiplier = Math.min(2, Math.max(0.5, salience * 10));
      weightedWarnPenalty += multiplier;
    }
    weightedWarnPenalty += regions.filter((r) => r.severity === 'warn').length;

    // When pixel comparison didn't run, use DOM-only score to avoid
    // inflating the result with a phantom 30% perfect pixel score
    const matchPercentage = pixelDiff.pixelComparisonRan
      ? domMatchRate * 0.7 + pixelMatchRate * 0.3
      : domMatchRate;

    // Apply severity penalties as a fraction of matched elements
    // An element with any fail mismatch is a "partial match" — penalize proportionally
    const totalElements = Math.max(1, domDiff.matches + domDiff.missing.length);
    const failFraction = weightedFailPenalty / totalElements;
    const warnFraction = weightedWarnPenalty / totalElements;
    const penalty = failFraction * 0.3 + warnFraction * 0.1; // Up to 30% for all-fail, 10% for all-warn
    const adjustedMatchPercentage = Math.max(0, matchPercentage * (1 - penalty));

    // Grade based on adjusted match percentage
    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    if (adjustedMatchPercentage > 0.95) {
      grade = 'A';
    } else if (adjustedMatchPercentage > 0.85) {
      grade = 'B';
    } else if (adjustedMatchPercentage > 0.7) {
      grade = 'C';
    } else if (adjustedMatchPercentage > 0.5) {
      grade = 'D';
    } else {
      grade = 'F';
    }

    const summary = this.feedbackGenerator.generateSummary({
      overall: {
        matchPercentage: adjustedMatchPercentage,
        grade,
        summary: '', // Will be filled in
      },
      domDiff,
      pixelDiff,
      regions,
      feedback: [],
      timestamp: Date.now(),
    });

    return {
      matchPercentage: adjustedMatchPercentage,
      grade,
      summary,
    };
  }

  /**
   * Check if two bounds overlap at all.
   */
  private boundsOverlap(a: { x: number; y: number; width: number; height: number }, b: { x: number; y: number; width: number; height: number }): boolean {
    return !(
      a.x + a.width < b.x ||
      b.x + b.width < a.x ||
      a.y + a.height < b.y ||
      b.y + b.height < a.y
    );
  }

  /**
   * Load design state from various sources.
   */
  private async loadDesignState(source: CompareOptions['designSource']): Promise<DesignState> {
    if (source.designState) {
      return source.designState;
    } else if (source.pencilFile) {
      const fs = await import('fs/promises');
      const content = await fs.readFile(source.pencilFile, 'utf-8');
      const parser = new PencilParser();
      return parser.parse(JSON.parse(content), {
        frameName: source.pencilFrame,
        themeMode: source.pencilTheme,
      });
    } else if (source.figmaFileKey) {
      // Load from Figma API
      return this.designParser.parseFromFigma(
        source.figmaFileKey,
        source.figmaNodeId
      );
    } else if (source.tokenFile) {
      // Load from design tokens file
      // parseFromTokenFile returns DesignTokens, wrap in a DesignState
      const tokens = await this.designParser.parseFromTokenFile(source.tokenFile);
      return {
        id: 'tokens',
        name: source.tokenFile,
        viewport: { width: 1280, height: 800 },
        nodes: [],
        tokens,
      };
    } else {
      // Default empty state
      return {
        id: 'default',
        name: 'Default',
        viewport: { width: 1280, height: 800 },
        nodes: [],
      };
    }
  }

  /**
   * Load reference image from file path or URL.
   */
  private async loadReferenceImage(path: string): Promise<Buffer> {
    // If path is URL, fetch it
    if (path.startsWith('http://') || path.startsWith('https://')) {
      const response = await fetch(path);
      const arrayBuffer = await response.arrayBuffer();
      return Buffer.from(arrayBuffer);
    }

    // Otherwise read from file system
    const fs = await import('fs/promises');
    return fs.readFile(path);
  }

  /**
   * Cleanup resources.
   */
  async close(): Promise<void> {
    await this.screenshotEngine.close();
  }
}
