/**
 * Detection accuracy benchmark suite.
 *
 * For each fixture:
 * 1. Capture build screenshot via ScreenshotEngine
 * 2. Capture design screenshot as reference
 * 3. Run ComparisonEngine.compare()
 * 4. Score feedback against ground truth
 * 5. Track cost
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { ScreenshotEngine } from '../../core/screenshot-engine.js';
import { ComparisonEngine } from '../../core/comparison-engine.js';
import { getAllFixtures } from '../fixtures/index.js';
import { scoreFixture, aggregateResults } from './scorer.js';
import { CostTracker } from '../cost/tracker.js';
import { writeDetectionReport } from '../cost/reporter.js';
import type { DetectionResult, TestFixture } from '../types.js';
import { writeFile, mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';

describe('Detection Accuracy Benchmark', () => {
  let screenshotEngine: ScreenshotEngine;
  let comparisonEngine: ComparisonEngine;
  let costTracker: CostTracker;
  const results: DetectionResult[] = [];

  beforeAll(async () => {
    screenshotEngine = new ScreenshotEngine();
    comparisonEngine = new ComparisonEngine();
    costTracker = new CostTracker();

    await costTracker.track('init-engines', async () => {
      await screenshotEngine.init();
      await comparisonEngine.init();
    });
  });

  afterAll(async () => {
    try {
      const report = aggregateResults(results, costTracker.getSummary());
      await writeDetectionReport(report);

      console.log('\n--- Detection Benchmark Summary ---');
      console.log(`Fixtures: ${results.length}`);
      console.log(`Precision: ${(report.aggregate.precision * 100).toFixed(1)}%`);
      console.log(`Recall: ${(report.aggregate.recall * 100).toFixed(1)}%`);
      console.log(`F1: ${(report.aggregate.f1 * 100).toFixed(1)}%`);
      console.log(`Time: ${report.cost.totalTimeMs.toFixed(0)}ms`);

      await rm(join(process.cwd(), 'bench-results', '.tmp'), { recursive: true, force: true });
    } finally {
      await screenshotEngine.close();
      await comparisonEngine.close();
    }
  }, 30_000);

  const fixtures = getAllFixtures();

  for (const fixture of fixtures) {
    it(`${fixture.id}: ${fixture.name}`, async () => {
      const result = await costTracker.track(`fixture-${fixture.id}`, async () => {
        return await runFixture(fixture, screenshotEngine, comparisonEngine);
      });

      results.push(result);

      // Log per-fixture results
      const tp = result.truePositives.length;
      const fp = result.falsePositives.length;
      const fn = result.falseNegatives.length;
      console.log(
        `  ${fixture.id}: P=${(result.precision * 100).toFixed(0)}% R=${(result.recall * 100).toFixed(0)}% F1=${(result.f1 * 100).toFixed(0)}% (TP=${tp} FP=${fp} FN=${fn})`
      );
    });
  }

  it('aggregate F1 meets minimum threshold', () => {
    if (results.length === 0) return; // Skip if no fixtures ran
    const report = aggregateResults(results, costTracker.getSummary());
    // F1 threshold: raised after cascade suppression + fixture precision improvements.
    // Baseline: 9.5% → 28.8% → 62.1% → 72.5% → 100%.
    expect(report.aggregate.f1).toBeGreaterThanOrEqual(0.95);
  });
});

async function runFixture(
  fixture: TestFixture,
  screenshotEngine: ScreenshotEngine,
  comparisonEngine: ComparisonEngine,
): Promise<DetectionResult> {
  // Capture design screenshot as reference image
  const designDataUrl = `data:text/html,${encodeURIComponent(fixture.designHtml)}`;
  const designScreenshot = await screenshotEngine.capture({
    url: designDataUrl,
    viewport: fixture.designState.viewport,
    disableAnimations: true,
  });

  // Write reference image to temp file for ComparisonEngine
  const tmpDir = join(process.cwd(), 'bench-results', '.tmp');
  await mkdir(tmpDir, { recursive: true });
  const refImagePath = join(tmpDir, `ref-${fixture.id}.png`);
  await writeFile(refImagePath, designScreenshot.image);

  // Build URL
  const buildDataUrl = `data:text/html,${encodeURIComponent(fixture.buildHtml)}`;

  // Run comparison with fixture's design state for DOM comparison
  const comparison = await comparisonEngine.compare({
    designSource: {
      referenceImage: refImagePath,
      designState: fixture.designState,
    },
    buildUrl: buildDataUrl,
    viewport: fixture.designState.viewport,
  });

  // Inject design state nodes for DOM comparison
  // ComparisonEngine uses its own design parsing, but we need DOM comparison
  // against our fixture's design state. For the benchmark, we use the
  // feedback generated by the full pipeline.

  return scoreFixture(fixture.id, comparison.feedback, fixture.groundTruth);
}
